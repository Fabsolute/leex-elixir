# The source of this file is part of leex distribution, as such it
# has the same Copyright as the other files in the leex
# distribution. The Copyright is defined in the accompanying file
# COPYRIGHT. However, the resultant scanner generated by leex is the
# property of the creator of the scanner and is not covered by that
# Copyright.

@@module



  # User code. This is placed here to allow extra attributes.

@@code

  def format_error({:illegal, error}) do
    "illegal characters #{error}"
  end

  def format_error({:user, error}), do: error

  def string(string), do: string(string, 1)

  def string(string, line), do: string(string, line, string, [])

  # string(string, line, token_string, tokens) -> {:ok,tokens,line} | {:error,error_info,line}
  # Note the line number going into yystate, line, is line of token
  # start while line number returned is line of token end. We want line
  # of token start.

  # No partial tokens!
  defp string("", line, "", tokens) do
    {:ok, yyrev(tokens), line}
  end

  defp string(string, line, token_string, tokens) do
    case yystate(yystate(), string, line, 0, :reject, 0) do
      # Accepting end state
      {accept, alen, string, line_1} ->
        string_cont(string, line_1, yyaction(accept, alen, token_string, line), tokens)

      # Accepting transition state
      {accept, alen, string, line_1, _s} ->
        string_cont(string, line_1, yyaction(accept, alen, token_string, line), tokens)

      # After a non-accepting state
      {:reject, _alen, tlen, _string, line_1, _s} ->
        {:error, {:line, __MODULE__, {:illegal, yypre(token_string, tlen + 1)}}, line_1,tokens}

      {accept, alen, tlen, _string, line_1, _s} ->
        token_string_2 = yysuf(token_string, alen)
        line_2 = adjust_line(tlen, alen, token_string_2, line_1)
        string_cont(token_string_2, line_2, yyaction(accept, alen, token_string, line), tokens)
    end
  end

  # string_cont(string, line, token, tokens)
  #  Test for and remove the end token wrapper. Push back characters
  #  are prepended to RestChars.

  defp string_cont(string, line, {:token, token}, tokens) do
    string(string, line, string, [token | tokens])
  end

  defp string_cont(string, line, {:token, token, push}, tokens) do
    string = push <> string
    string(string, line, string, [token | tokens])
  end

  defp string_cont(string, line, {:end_token, token}, tokens) do
    string(string, line, string, [token | tokens])
  end

  defp string_cont(string, line, {:end_token, token, push}, tokens) do
    string = push <> string
    string(string, line, string, [token | tokens])
  end

  defp string_cont(string, line, :skip_token, tokens) do
    string(string, line, string, tokens)
  end

  defp string_cont(string, line, {:skip_token, push}, tokens) do
    string = push <> string
    string(string, line, string, tokens)
  end

  defp string_cont(_string, line, {:error, error}, _tokens) do
    {:error, {line, __MODULE__, {:user, error}}, line}
  end

  # token(continuation, string) ->
  # token(continuation, string, line) ->
  #  {:more,continuation} | {:done,return_val,rest_string}
  # Must be careful when re-entering to append the latest characters to the
  # after characters in an accept. The continuation is:
  # {:token,state,current_line,token_val,token_len,token_line,accept_action,accept_len}

  def token(continuation, string), do: token(continuation, string, 1)

  def token(string, [], line) do
    token(yystate(), string, line, string, 0, line, :reject, 0)
  end

  def token(
         {:token, state, line, token_string, token_len, token_line, accept_action, accept_len},
         string,
         _
       ) do
    token(
      state,
      string,
      line,
      token_string <> string,
      token_len,
      token_line,
      accept_action,
      accept_len
    )
  end

  # token(state, string, line, token_string, token_len, token_line,
  #  accept_action, accept_len) ->
  #  {:more,continuation} | {:done,return_val,rest_string}
  #  The argument order is chosen to be more efficient.

  defp token(state, string, line, token_string, token_len, token_line, accept_action, accept_len) do
    case yystate(state, string, line, token_len, accept_action, accept_len) do
      # Accepting end state, we have a token.
      {accept_action, accept_len, string, line} ->
        token_cont(string, line, yyaction(accept_action, accept_len, token_string, token_line))

      # Accepting transition state, can take more chars.
      # Need more chars to check
      {accept_action, accept_len, [], line, state} ->
        {:more,
         {:token, state, line, token_string, accept_len, token_line, accept_action, accept_len}}

      # Take what we got
      {accept_action, accept_len, string, line, _state} ->
        token_cont(string, line, yyaction(accept_action, accept_len, token_string, token_line))

      # After a non-accepting state, maybe reach accept state later.
      # Need more chars to check
      {accept_action, accept_len, token_len, [], line, state} ->
        {:more,
         {:token, state, line, token_string, token_len, token_line, accept_action, accept_len}}

      # No token match
      {:reject, _accept_len, token_len, :eof, line, _state} ->
        # Check for partial token which is error.
        return_value =
          if token_len > 0 do
            {:error,
             {
               token_line,
               __MODULE__,
               # Skip eof tail in token_val.
               {:illegal, yypre(token_string, token_len)}
             }, line}
          else
            {:eof, line}
          end

        {:done, return_value, :eof}

      # No token match
      {:reject, _accept_len, token_len, string, line, _state} ->
        error = {token_line, __MODULE__, {:illegal, yypre(token_string, token_len + 1)}}
        {:done, {:error, error, line}, string}

      # Use last accept match
      {accept_action, accept_len, token_len, _string, line, _state} ->
        token_string_2 = yysuf(token_string, accept_len)
        line = adjust_line(token_len, accept_len, token_string_2, line)

        token_cont(
          token_string_2,
          line,
          yyaction(accept_action, accept_len, token_string, token_line)
        )
    end
  end

  # token_cont(string, line, token)
  # If we have a token or error then return done, else if we have a
  # :skip_token then continue.

  defp token_cont(string, line, {:token, token}) do
    {:done, {:ok, token, line}, string}
  end

  defp token_cont(string, line, {:token, token, push}) do
    string = push <> string
    {:done, {:ok, token, line}, string}
  end

  defp token_cont(string, line, {:end_token, token}) do
    {:done, {:ok, token, line}, string}
  end

  defp token_cont(string, line, {:end_token, token, push}) do
    string = push <> string
    {:done, {:ok, token, line}, string}
  end

  defp token_cont(string, line, :skip_token) do
    token(yystate(), string, line, string, 0, line, :reject, 0)
  end

  defp token_cont(string, line, {:skip_token, push}) do
    string = push <> string
    token(yystate(), string, line, string, 0, line, :reject, 0)
  end

  defp token_cont(string, line, {:error, error}) do
    {:done, {:error, {line, __MODULE__, {:user, error}}, line}, string}
  end

  #  tokens(continuation, string, line) ->
  #  {:more,continuation} | {:done,return_val,rest_string}
  #  Must be careful when re-entering to append the latest characters to the
  #  after characters in an accept. The continuation is:
  #  {:tokens,state,current_line,token_val,token_len,token_line,tokens,accept_action,accept_len}
  #  {:skip_tokens,state,current_line,token_val,token_len,token_line,error,accept_action,accept_len}

  def tokens(continuation, string), do: tokens(continuation, string, 1)

  def tokens([], string, line) do
    tokens(yystate(), string, line, string, 0, line, [], :reject, 0)
  end

  def tokens(
         {:tokens, state, line, token_val, token_len, token_line, tokens, accept_action,
          accept_len},
         string,
         _
       ) do
    tokens(
      state,
      string,
      line,
      token_val <> string,
      token_len,
      token_line,
      tokens,
      accept_action,
      accept_len
    )
  end

  def tokens(
         {:skip_tokens, state, line, token_val, token_len, token_line, error, accept_action,
          accept_len},
         string,
         _
       ) do
    skip_tokens(
      state,
      string,
      line,
      token_val <> string,
      token_len,
      token_line,
      error,
      accept_action,
      accept_len
    )
  end

  # tokens(state, string, line, token_val, token_len, token_line, tokens,
  # accept_action, accept_len) ->
  # {:more,continuation} | {:done,return_val,rest_string}

  defp tokens(
         state,
         string,
         line,
         token_val,
         token_len,
         token_line,
         tokens,
         accept_action,
         accept_len
       ) do
    case yystate(state, string, line, token_len, accept_action, accept_len) do
      # Accepting end state, we have a token.
      {accept_action, accept_len, string, line} ->
        tokens_cont(
          string,
          line,
          yyaction(accept_action, accept_len, token_val, token_line),
          tokens
        )

      # Accepting transition state, can take more chars.
      # Need more chars to check
      {accept_action, accept_len, [], line, state} ->
        {:more,
         {:tokens, state, line, token_val, accept_len, token_line, tokens, accept_action,
          accept_len}}

      # Take what we got
      {accept_action, accept_len, string, line, _state} ->
        tokens_cont(
          string,
          line,
          yyaction(accept_action, accept_len, token_val, token_line),
          tokens
        )

      # After a non-accepting state, maybe reach accept state later.
      # Need more chars to check
      {accept_action, accept_len, token_len, [], line, state} ->
        {:more,
         {:tokens, state, line, token_val, token_len, token_line, tokens, accept_action,
          accept_len}}

      # No token match
      {:reject, _accept_len, token_len, :eof, line, _state} ->
        # Check for partial token which is error, no need to skip here.
        return_val =
          cond do
            token_len > 0 ->
              {:error,
               {
                 token_line,
                 __MODULE__,
                 # Skip eof tail in token_val.
                 {:illegal, yypre(token_val, token_len)}
               }, line}

            tokens == [] ->
              {:eof, line}

            true ->
              {:ok, yyrev(tokens), line}
          end

        {:done, return_val, :eof}

      {:reject, _accept_len, token_len, _string, line, _state} ->
        # Skip rest of tokens.
        error = {line, __MODULE__, {:illegal, yypre(token_val, token_len + 1)}}
        skip_tokens(yysuf(token_val, token_len + 1), line, error)

      {accept_action, accept_len, token_len, _string, line, _state} ->
        token = yyaction(accept_action, accept_len, token_val, token_line)
        token_val = yysuf(token_val, accept_len)
        line = adjust_line(token_len, accept_len, token_val, line)
        tokens_cont(token_val, line, token, tokens)
    end
  end

  # tokens_cont(string, line, token, tokens)
  # If we have an end_token or error then return done, else if we have
  # a token then save it and continue, else if we have a skip_token
  # just continue.

  defp tokens_cont(string, line, {:token, token}, tokens) do
    tokens(yystate(), string, line, string, 0, line, [token | tokens], :reject, 0)
  end

  defp tokens_cont(string, line, {:token, token, push}, tokens) do
    string = push <> string
    tokens(yystate(), string, line, string, 0, line, [token | tokens], :reject, 0)
  end

  defp tokens_cont(string, line, {:end_token, token}, tokens) do
    {:done, {:ok, yyrev(tokens, [token]), line}, string}
  end

  defp tokens_cont(string, line, {:end_token, token, push}, tokens) do
    string = push <> string
    {:done, {:ok, yyrev(tokens, [token]), line}, string}
  end

  defp tokens_cont(string, line, :skip_token, tokens) do
    tokens(yystate(), string, line, string, 0, line, tokens, :reject, 0)
  end

  defp tokens_cont(string, line, {:skip_token, push}, tokens) do
    string = push <> string
    tokens(yystate(), string, line, string, 0, line, tokens, :reject, 0)
  end

  defp tokens_cont(string, line, {:error, error}, _tokens) do
    skip_tokens(string, line, {line, __MODULE__, {:user, error}})
  end

  # skip_tokens(string, line, error) -> {:done,{:error,error,line},string}
  #  Skip tokens until an end token, junk everything and return the error.

  defp skip_tokens(string, line, error) do
    skip_tokens(yystate(), string, line, string, 0, line, error, :reject, 0)
  end

  # skip_tokens(state, string, line, token_val, token_len, token_line, tokens,
  # accept_action, accept_len) ->
  # {:more,continuation} | {:done,return_val,rest_string}

  defp skip_tokens(
         state,
         string,
         line,
         token_val,
         token_len,
         token_line,
         error,
         accept_action,
         accept_len
       ) do
    case yystate(state, string, line, token_len, accept_action, accept_len) do
      # Accepting end state
      {accept_action, accept_len, string, line} ->
        skip_cont(string, line, yyaction(accept_action, accept_len, token_val, token_line), error)

      # After an accepting state
      {accept_action, accept_len, [], line, string} ->
        {:more,
         {:skip_tokens, string, line, token_val, accept_len, token_line, error, accept_action,
          accept_len}}

      {accept_action, accept_len, string, line, _s} ->
        skip_cont(string, line, yyaction(accept_action, accept_len, token_val, token_line), error)

      # After a non-accepting state
      {accept_action, accept_len, token_len, [], line, string} ->
        {:more,
         {:skip_tokens, string, line, token_val, token_len, token_line, error, accept_action,
          accept_len}}

      {:reject, _accept_len, _token_len, :eof, line, _s} ->
        {:done, {:error, error, line}, :eof}

      {:reject, _accept_len, token_len, _string, line, _s} ->
        skip_tokens(yysuf(token_val, token_len + 1), line, error)

      {accept_action, accept_len, token_len, _string, line, _s} ->
        token = yyaction(accept_action, accept_len, token_val, token_line)
        token_val = yysuf(token_val, accept_len)
        line = adjust_line(token_len, accept_len, token_val, line)
        skip_cont(token_val, line, token, error)
    end
  end

  # skip_cont(string, line, token, error)
  # Skip tokens until we have an end_token or error then return done
  # with the original rror.

  defp skip_cont(string, line, {:token, _token}, error) do
    skip_tokens(yystate(), string, line, string, 0, line, error, :reject, 0)
  end

  defp skip_cont(string, line, {:token, _token, push}, error) do
    string = push <> string
    skip_tokens(yystate(), string, line, string, 0, line, error, :reject, 0)
  end

  defp skip_cont(string, line, {:end_token, _token}, error) do
    {:done, {:error, error, line}, string}
  end

  defp skip_cont(string, line, {:end_token, _token, push}, error) do
    string = push <> string
    {:done, {:error, error, line}, string}
  end

  defp skip_cont(string, line, :skip_token, error) do
    skip_tokens(yystate(), string, line, string, 0, line, error, :reject, 0)
  end

  defp skip_cont(string, line, {:skip_token, push}, error) do
    string = push <> string
    skip_tokens(yystate(), string, line, string, 0, line, error, :reject, 0)
  end

  defp skip_cont(string, line, {:error, _error}, error) do
    skip_tokens(yystate(), string, line, string, 0, line, error, :reject, 0)
  end

  defp yyrev(list), do: Enum.reverse(list)
  defp yyrev(list, tail), do: Enum.reverse(list, tail)
  defp yypre(string, n), do: String.slice(string, 0..(n - 1))
  defp yysuf(string, n), do: Enum.drop(string, n)

  # adjust_line(token_len, accept_len, string, line) -> line
  # Make sure that newlines in Chars are not counted twice.
  # Line has been updated with respect to newlines in the prefix of
  # Chars consisting of (token_len - accept_len) characters.

  defp adjust_line(token_len, token_len, _string, line), do: line

  defp adjust_line(token_len, accept_len, <<?\n, string::binary>>, line) do
    adjust_line(token_len - 1, accept_len, string, line - 1)
  end

  defp adjust_line(token_len, accept_len, <<_, string::binary>>, line) do
    adjust_line(token_len - 1, accept_len, string, line)
  end

  # yystate() -> initial_state.
  # yystate(state, string, line, token_len, accept_action, accept_len) ->
  #  {accept_action, accept_len, string, line} |
  #  {accept_action, accept_len, string, line, state} |
  #  {:reject, accept_len, token_len, string, line, state} |
  #  {accept_action, accept_len, token_len, string, line, state}
  #  Generated state transition functions. The non-accepting end state
  #  return signal either an unrecognised character or end of current
  #  input.

@@dfa

  # yyaction(accept_action, token_len, token_val, token_line) ->
  # {:token,token} | {:end_token, token} | :skip_token | {:error,error}
  # Generated action function.

@@actions

end
